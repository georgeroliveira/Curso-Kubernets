# =====================================================
# Lab 03 - Deploy Automatizado com Docker Compose
# M√≥dulo 07 - CI/CD
# =====================================================
# Pipeline que faz build, testa e deploya stack completa

name: üê≥ Deploy Docker Compose Stack

on:
  push:
    branches: [main, develop]
    paths:
      - 'docker-compose*.yml'
      - 'Dockerfile*'
      - '.github/workflows/deploy-compose.yml'
      - 'src/**'
      - 'nginx/**'
  pull_request:
    branches: [main]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - local
          - staging
          - production
      action:
        description: 'Deployment action'
        required: true
        default: 'deploy'
        type: choice
        options:
          - deploy
          - rollback
          - restart
          - logs

env:
  COMPOSE_PROJECT_NAME: myapp
  DOCKER_REGISTRY: ghcr.io
  POSTGRES_VERSION: '14'
  REDIS_VERSION: '7'
  NGINX_VERSION: 'alpine'

jobs:
  # =====================================================
  # Prepare Environment
  # =====================================================
  prepare:
    name: üé¨ Prepare Deployment
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      environment: ${{ steps.env.outputs.environment }}
    
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v3
      
      - name: üîñ Generate version tag
        id: version
        run: |
          VERSION="${GITHUB_REF_NAME}-$(date +%Y%m%d%H%M%S)-${GITHUB_SHA::8}"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "üìå Version: $VERSION"
      
      - name: üåç Determine environment
        id: env
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            ENV="${{ github.event.inputs.environment }}"
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            ENV="production"
          elif [[ "${{ github.ref }}" == "refs/heads/develop" ]]; then
            ENV="staging"
          else
            ENV="local"
          fi
          echo "environment=$ENV" >> $GITHUB_OUTPUT
          echo "üéØ Target environment: $ENV"
      
      - name: üìù Create project structure
        run: |
          # Create directory structure
          mkdir -p src nginx postgres redis scripts
          
          # Create main application
          cat > src/index.js <<'EOF'
          const express = require('express');
          const redis = require('redis');
          const { Pool } = require('pg');
          
          const app = express();
          const PORT = process.env.PORT || 3000;
          
          // Database connection
          const pool = new Pool({
            host: process.env.DB_HOST || 'postgres',
            user: process.env.DB_USER || 'postgres',
            password: process.env.DB_PASSWORD || 'postgres',
            database: process.env.DB_NAME || 'myapp'
          });
          
          // Redis connection
          const redisClient = redis.createClient({
            url: `redis://${process.env.REDIS_HOST || 'redis'}:6379`
          });
          
          redisClient.connect().catch(console.error);
          
          app.use(express.json());
          
          // Routes
          app.get('/', async (req, res) => {
            const visits = await redisClient.incr('visits');
            res.json({
              message: 'Hello from Docker Compose CI/CD!',
              version: process.env.VERSION || 'dev',
              visits: visits,
              environment: process.env.NODE_ENV || 'development'
            });
          });
          
          app.get('/health', async (req, res) => {
            try {
              // Check database
              await pool.query('SELECT 1');
              // Check Redis
              await redisClient.ping();
              res.status(200).json({ status: 'healthy', services: { db: 'ok', redis: 'ok' } });
            } catch (error) {
              res.status(503).json({ status: 'unhealthy', error: error.message });
            }
          });
          
          app.listen(PORT, () => {
            console.log(`Server running on port ${PORT}`);
          });
          EOF
          
          # Create package.json
          cat > src/package.json <<'EOF'
          {
            "name": "docker-compose-app",
            "version": "1.0.0",
            "main": "index.js",
            "scripts": {
              "start": "node index.js",
              "dev": "nodemon index.js"
            },
            "dependencies": {
              "express": "^4.18.0",
              "pg": "^8.11.0",
              "redis": "^4.6.0"
            },
            "devDependencies": {
              "nodemon": "^2.0.0"
            }
          }
          EOF
          
          # Create Dockerfile for app
          cat > src/Dockerfile <<'EOF'
          FROM node:16-alpine
          
          WORKDIR /app
          
          COPY package*.json ./
          RUN npm ci --only=production
          
          COPY . .
          
          EXPOSE 3000
          
          CMD ["node", "index.js"]
          EOF
          
          # Create Nginx configuration
          cat > nginx/nginx.conf <<'EOF'
          events {
              worker_connections 1024;
          }
          
          http {
              upstream app {
                  least_conn;
                  server app1:3000 max_fails=3 fail_timeout=30s;
                  server app2:3000 max_fails=3 fail_timeout=30s;
                  server app3:3000 max_fails=3 fail_timeout=30s;
              }
              
              server {
                  listen 80;
                  
                  location / {
                      proxy_pass http://app;
                      proxy_set_header Host $host;
                      proxy_set_header X-Real-IP $remote_addr;
                      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                      proxy_connect_timeout 30s;
                      proxy_send_timeout 30s;
                      proxy_read_timeout 30s;
                  }
                  
                  location /nginx-health {
                      access_log off;
                      return 200 "healthy\n";
                      add_header Content-Type text/plain;
                  }
              }
          }
          EOF
          
          # Create PostgreSQL init script
          cat > postgres/init.sql <<'EOF'
          CREATE DATABASE myapp;
          
          \c myapp;
          
          CREATE TABLE IF NOT EXISTS visits (
              id SERIAL PRIMARY KEY,
              timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
              ip VARCHAR(45),
              user_agent TEXT
          );
          
          CREATE TABLE IF NOT EXISTS deployments (
              id SERIAL PRIMARY KEY,
              version VARCHAR(255),
              deployed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
              deployed_by VARCHAR(255),
              environment VARCHAR(50)
          );
          
          -- Insert initial deployment record
          INSERT INTO deployments (version, deployed_by, environment)
          VALUES ('initial', 'ci-cd-pipeline', 'development');
          EOF

  # =====================================================
  # Build and Test
  # =====================================================
  build-test:
    name: üèóÔ∏è Build and Test
    runs-on: ubuntu-latest
    needs: prepare
    
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v3
      
      - name: üê≥ Set up Docker Buildx
        uses: docker/setup-buildx-action@v2
      
      - name: üìù Create docker-compose.yml
        run: |
          cat > docker-compose.yml <<'EOF'
          version: '3.8'
          
          services:
            # PostgreSQL Database
            postgres:
              image: postgres:${POSTGRES_VERSION:-14}
              container_name: ${COMPOSE_PROJECT_NAME}_postgres
              environment:
                POSTGRES_USER: ${DB_USER:-postgres}
                POSTGRES_PASSWORD: ${DB_PASSWORD:-postgres}
                POSTGRES_DB: ${DB_NAME:-myapp}
              volumes:
                - postgres_data:/var/lib/postgresql/data
                - ./postgres/init.sql:/docker-entrypoint-initdb.d/init.sql
              ports:
                - "${DB_PORT:-5432}:5432"
              networks:
                - app_network
              healthcheck:
                test: ["CMD-SHELL", "pg_isready -U postgres"]
                interval: 10s
                timeout: 5s
                retries: 5
              restart: unless-stopped
            
            # Redis Cache
            redis:
              image: redis:${REDIS_VERSION:-7}-alpine
              container_name: ${COMPOSE_PROJECT_NAME}_redis
              ports:
                - "${REDIS_PORT:-6379}:6379"
              volumes:
                - redis_data:/data
              networks:
                - app_network
              healthcheck:
                test: ["CMD", "redis-cli", "ping"]
                interval: 10s
                timeout: 5s
                retries: 5
              restart: unless-stopped
            
            # Application (3 instances for load balancing)
            app1:
              build:
                context: ./src
                dockerfile: Dockerfile
              container_name: ${COMPOSE_PROJECT_NAME}_app1
              environment:
                NODE_ENV: ${NODE_ENV:-development}
                PORT: 3000
                DB_HOST: postgres
                DB_USER: ${DB_USER:-postgres}
                DB_PASSWORD: ${DB_PASSWORD:-postgres}
                DB_NAME: ${DB_NAME:-myapp}
                REDIS_HOST: redis
                VERSION: ${VERSION:-dev}
              depends_on:
                postgres:
                  condition: service_healthy
                redis:
                  condition: service_healthy
              networks:
                - app_network
              restart: unless-stopped
            
            app2:
              extends:
                service: app1
              container_name: ${COMPOSE_PROJECT_NAME}_app2
            
            app3:
              extends:
                service: app1
              container_name: ${COMPOSE_PROJECT_NAME}_app3
            
            # Nginx Load Balancer
            nginx:
              image: nginx:${NGINX_VERSION:-alpine}
              container_name: ${COMPOSE_PROJECT_NAME}_nginx
              ports:
                - "${HTTP_PORT:-80}:80"
              volumes:
                - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
              depends_on:
                - app1
                - app2
                - app3
              networks:
                - app_network
              healthcheck:
                test: ["CMD", "wget", "-q", "--spider", "http://localhost/nginx-health"]
                interval: 30s
                timeout: 10s
                retries: 3
              restart: unless-stopped
          
          networks:
            app_network:
              driver: bridge
          
          volumes:
            postgres_data:
            redis_data:
          EOF
      
      - name: üìù Create .env file
        run: |
          cat > .env <<EOF
          COMPOSE_PROJECT_NAME=${{ env.COMPOSE_PROJECT_NAME }}
          NODE_ENV=${{ needs.prepare.outputs.environment }}
          VERSION=${{ needs.prepare.outputs.version }}
          
          # Database
          DB_USER=postgres
          DB_PASSWORD=postgres
          DB_NAME=myapp
          DB_PORT=5432
          
          # Redis
          REDIS_PORT=6379
          
          # Nginx
          HTTP_PORT=80
          
          # Versions
          POSTGRES_VERSION=${{ env.POSTGRES_VERSION }}
          REDIS_VERSION=${{ env.REDIS_VERSION }}
          NGINX_VERSION=${{ env.NGINX_VERSION }}
          EOF
      
      - name: üèóÔ∏è Build services
        run: |
          docker-compose build --parallel
      
      - name: üöÄ Start services
        run: |
          docker-compose up -d
          echo "Waiting for services to be ready..."
          sleep 30
      
      - name: üìä Check services status
        run: |
          docker-compose ps
          docker-compose logs --tail=20
      
      - name: üß™ Run health checks
        run: |
          echo "Testing Nginx..."
          curl -f http://localhost/nginx-health || exit 1
          
          echo "Testing App through load balancer..."
          for i in {1..10}; do
            curl -f http://localhost/ || exit 1
            sleep 1
          done
          
          echo "Testing App health endpoint..."
          curl -f http://localhost/health || exit 1
      
      - name: üß™ Run integration tests
        run: |
          # Test database connectivity
          docker-compose exec -T postgres psql -U postgres -d myapp -c "SELECT COUNT(*) FROM deployments;"
          
          # Test Redis connectivity
          docker-compose exec -T redis redis-cli ping
          
          # Test load balancing
          echo "Testing load distribution..."
          for i in {1..30}; do
            curl -s http://localhost/ | jq -r '.environment'
          done
      
      - name: üìä Performance test
        run: |
          echo "Running basic performance test..."
          docker run --rm --network host \
            williamyeh/wrk \
            -t2 -c10 -d10s \
            http://localhost/ || true
      
      - name: üßπ Cleanup test environment
        if: always()
        run: |
          docker-compose down -v

  # =====================================================
  # Deploy
  # =====================================================
  deploy:
    name: üöÄ Deploy Stack
    runs-on: ubuntu-latest
    needs: [prepare, build-test]
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'
    environment:
      name: ${{ needs.prepare.outputs.environment }}
      url: https://${{ needs.prepare.outputs.environment }}.exemplo.com
    
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v3
      
      - name: üîê Configure deployment credentials
        run: |
          echo "Configuring credentials for ${{ needs.prepare.outputs.environment }}..."
          # Here you would configure actual deployment credentials
          # For example: SSH keys, cloud credentials, etc.
      
      - name: üìù Create deployment script
        run: |
          cat > deploy.sh <<'EOF'
          #!/bin/bash
          set -e
          
          ENVIRONMENT=$1
          VERSION=$2
          ACTION=${3:-deploy}
          
          echo "üöÄ Deploying version $VERSION to $ENVIRONMENT"
          
          case $ACTION in
            deploy)
              echo "üì¶ Pulling latest images..."
              docker-compose pull
              
              echo "üîÑ Performing rolling update..."
              docker-compose up -d --no-deps --scale app1=1 app1
              sleep 10
              docker-compose up -d --no-deps --scale app2=1 app2
              sleep 10
              docker-compose up -d --no-deps --scale app3=1 app3
              sleep 10
              
              echo "üîÑ Updating nginx..."
              docker-compose up -d --no-deps nginx
              ;;
            
            rollback)
              echo "‚è™ Rolling back to previous version..."
              docker-compose down
              # Here you would restore previous version
              docker-compose up -d
              ;;
            
            restart)
              echo "üîÑ Restarting services..."
              docker-compose restart
              ;;
            
            logs)
              echo "üìã Fetching logs..."
              docker-compose logs --tail=100
              ;;
          esac
          
          echo "‚úÖ Deployment completed!"
          EOF
          
          chmod +x deploy.sh
      
      - name: üöÄ Execute deployment
        run: |
          ./deploy.sh \
            ${{ needs.prepare.outputs.environment }} \
            ${{ needs.prepare.outputs.version }} \
            ${{ github.event.inputs.action || 'deploy' }}
      
      - name: üß™ Verify deployment
        run: |
          echo "Verifying deployment..."
          
          # Check if services are running
          docker-compose ps
          
          # Health checks
          curl -f http://localhost/health || exit 1
          
          # Check version
          DEPLOYED_VERSION=$(curl -s http://localhost/ | jq -r '.version')
          echo "Deployed version: $DEPLOYED_VERSION"
      
      - name: üìä Update deployment database
        run: |
          # Record deployment in database
          docker-compose exec -T postgres psql -U postgres -d myapp <<EOF
          INSERT INTO deployments (version, deployed_by, environment)
          VALUES ('${{ needs.prepare.outputs.version }}', '${{ github.actor }}', '${{ needs.prepare.outputs.environment }}');
          EOF
      
      - name: üì¢ Send notification
        if: always()
        run: |
          STATUS="${{ job.status }}"
          COLOR=$([ "$STATUS" == "success" ] && echo "good" || echo "danger")
          
          cat > notification.json <<EOF
          {
            "text": "Deployment $STATUS",
            "attachments": [{
              "color": "$COLOR",
              "fields": [
                {"title": "Environment", "value": "${{ needs.prepare.outputs.environment }}", "short": true},
                {"title": "Version", "value": "${{ needs.prepare.outputs.version }}", "short": true},
                {"title": "Deployed by", "value": "${{ github.actor }}", "short": true},
                {"title": "Status", "value": "$STATUS", "short": true}
              ]
            }]
          }
          EOF
          
          echo "Notification would be sent to Slack/Discord/Email"

  # =====================================================
  # Monitoring
  # =====================================================
  monitor:
    name: üìä Post-Deployment Monitoring
    runs-on: ubuntu-latest
    needs: [deploy]
    if: success()
    
    steps:
      - name: üìä Monitor for 5 minutes
        run: |
          echo "Monitoring deployment for stability..."
          
          for i in {1..5}; do
            echo "Minute $i/5"
            
            # Check health
            if ! curl -sf http://localhost/health > /dev/null; then
              echo "‚ùå Health check failed!"
              exit 1
            fi
            
            # Check response times
            RESPONSE_TIME=$(curl -o /dev/null -s -w '%{time_total}\n' http://localhost/)
            echo "Response time: ${RESPONSE_TIME}s"
            
            # Check error rate (simulated)
            ERROR_RATE=$((RANDOM % 5))
            echo "Error rate: ${ERROR_RATE}%"
            
            if [ $ERROR_RATE -gt 10 ]; then
              echo "‚ùå High error rate detected!"
              exit 1
            fi
            
            sleep 60
          done
          
          echo "‚úÖ Deployment stable!"
      
      - name: üè∑Ô∏è Tag successful deployment
        if: success()
        run: |
          echo "Creating deployment tag..."
          TAG="${{ needs.prepare.outputs.environment }}-${{ needs.prepare.outputs.version }}"
          echo "Tag: $TAG"
          # git tag $TAG
          # git push origin $TAG

# =====================================================
# Usage Instructions:
# 
# 1. Push to develop branch ‚Üí Deploy to staging
# 2. Push to main branch ‚Üí Deploy to production
# 3. Manual trigger ‚Üí Choose environment and action
# 
# Actions available:
# - deploy: Normal deployment
# - rollback: Rollback to previous version
# - restart: Restart services
# - logs: View logs
# =====================================================